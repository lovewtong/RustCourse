因为我们不能在同一时间多次将 s 作为可变变量借用。第一个可变 
的借入在 r1 中，并且必须持续到在 println！ 中使用它，但是在那个可变引用的创建和它的使用 
之间，我们又尝试在 r2 中创建另一个可变引用，该引用借用与 r1 相同的数据。 防止同一时间对 
同一数据进行多个可变引用的限制允许可变性，不过是以一种受限制的方式允许。新 Rustacean 们经 
常难以适应这一点，因为大部分语言中变量任何时候都是可变的。
这个限制的好处是 Rust 可以在编译时就避免数据竞争。数据竞争（data race）类似于竞态条件，它 
可由这三个行为造成：
两个或更多指针同时访问同一数据。 
至少有一个指针被用来写入数据。 
没有同步数据访问的机制。
数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发 
生，因为它甚至不会编译存在数据竞争的代码！

在任意给定时间，要么  
1.只能有一个可变引用,要么只能有多个不可变引用。 
2.引用必须总是有效的。