# RustCourse

1.https://course.rs/about-book.html rust学习
2.https://zh.practice.rs/why-exercise.html rust练习


### 2023/02/14
所有权 ownership
堆栈，得益于现代cpu的高速缓存，栈的效率比堆的效率高得多
- 栈是后进先出，栈的数据都必须占用大小已知且固定的内存空间
- 大小未知或者可变的数据我们将放在堆中，往堆上放入数据时，需要请求一块足够大的内存空间，再返回一个表示该位置地址的指针，再将这个指针推入栈中
- 写入效率:栈因为是有固定的内存空间，写入比堆快得多;读取效率得益于现代CPU的高速缓存功能，栈的效率也比堆高，因为栈可以存放于CPU的高速缓存中，但是堆只能存放于内存中;访问栈的数据也比堆的数据快，因为访问堆的数据必须要先访问栈再通过栈上的指针来访问内存

### 2023/02/20
- Rust中，每一个值都被一个变量所拥有，换句话说，该变量被称为值的拥有者
- 一个值一个拥有者
- 当所有者离开作用域范围时，该值将被丢弃(drop)
- 可变引用同时只能存在一个，防止多个可变引用导致错误
- 同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
- 引用必须总是有效的

### 2023/03/01
- 为啥 String 可变，而字符串字面值 str 却不可以？
- 就字符串字面值来说，我们在编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件中，这使得字符串字面值快速且高效，这主要得益于字符串字面值的不可变性。不幸的是，我们不能为了获得这种性能，而把每一个在编译时大小未知的文本都放进内存中（你也做不到！），因为有的字符串是在程序运行得过程中动态生成的。

- 对于 String 类型，为了支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，这些都是在程序运行时完成的：

- 首先向操作系统请求内存来存放 String 对象
在使用完成后，将内存释放，归还给操作系统
其中第一部分由 String::from 完成，它创建了一个全新的 String。

- 重点来了，到了第二部分，就是百家齐放的环节，在有垃圾回收 GC 的语言中，GC 来负责标记并清除这些不再使用的内存对象，这个过程都是自动完成，无需开发者关心，非常简单好用；但是在无 GC 的语言中，需要开发者手动去释放这些内存对象，就像创建对象需要通过编写代码来完成一样，未能正确释放对象造成的后果简直不可估量。

- 对于 Rust 而言，安全和性能是写到骨子里的核心特性，如果使用 GC，那么会牺牲性能；如果使用手动管理内存，那么会牺牲安全，这该怎么办？为此，Rust 的开发者想出了一个无比惊艳的办法：变量在离开作用域后，就自动释放其占用的内存：

- 
`#![allow(unused)]`
`fn main() {`
`{`
`    let s = String::from("hello"); // 从此处起，s 是有效的`

`    // 使用 s`
`}                                  // 此作用域已结束，`
`                                   // s 不再有效，内存被释放`
`}`

- 与其它系统编程语言的 free 函数相同，Rust 也提供了一个释放内存的函数： drop，但是不同的是，其它语言要手动调用 free 来释放每一个变量占用的内存，而 Rust 则在变量离开作用域时，自动调用 drop 函数: 上面代码中，Rust 在结尾的 } 处自动调用 drop。

- 其实，在 C++ 中，也有这种概念: Resource Acquisition Is Initialization (RAII)。如果你使用过 RAII 模式的话应该对 Rust 的 drop 函数并不陌生。
